---
layout: post
title: 'iOS Development: Types of Applications in XCode, Model-View-Controller (MVC),
  and Basic Object Interactions'
date: 2012-01-15 08:17:00.000000000 -08:00
categories:
- iOS
tags: []
status: publish
type: post
published: true
meta:
  blogger_blog: www.nikhilgopal.com
  blogger_author: Nikhil Gopal
  blogger_permalink: /2012/01/types-of-applications-in-xcode-model.html
  _blogger_self: https://www.blogger.com/feeds/3320739517310204273/posts/default/2066057018392158164
author:
  login: nikhilgopal@gmail.com
  email: nikhilgopal@gmail.com
  display_name: Nikhil Gopal
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p><u><b><span>Types of Applications in XCode:</span></b></u><br /><span><br /></span><br /><span><u>Navigation-based Application</u> - Exactly what it sounds like. Imagine the mail application. We select an option and it navigates to another page (or activity, if you come from the world of Android).</span><br /><span><br /></span><br /><span><u>OpenGL ES Application</u> - an application which uses OpenGL. This can be pretty heavy stuff.</span><br /><span><br /></span><br /><span><u>Tab Bar Application</u> - An application which is similar to a website with frames. There will be a tab pane at the bottom of the app with 4-5 options and choosing an option will change the activity the user is experiencing.</span><br /><span><br /></span><br /><span><u>Utility Application</u> - An interesting kind of application which kind of "flips." These apps tend to have a miniature "i" icon on the bottom right corner of the screen. Upon clicking the icon, the application "flips" into another activity.</span><br /><span><br /></span><br /><span><u>View-based Application</u> - Probably the most commonly selected project.</span><br /><span><br /></span><br /><span><u>Window-based Application</u> - this sort of project tends to be very bare. I suppose this is the "expert" developer mode where he or she has to pick and choose what components are required for the application.</span><br /><span><br /></span><br /><span><br /></span><br /><b><u><span>MVC (Model-View-Controller):</span></u></b><br /><span><br /></span><br /><span>It's just a software design pattern. The idea is to keep the models and the views separate from each other. The philosophy is that a developer should be able to make modifications to one without affecting other. The view never talks to the model. However, the model and the view both talk to the controller.</span><br /><span><br /></span><br /><span>My little memory trick to remember this paradigm is that: (1) model, view and controller are three good friends and (2) controller just happens to be a control freak and liaisons the group's communication. I'm sure I can think of a better mnemonic but this will do for now. Views are easy to make and are essentially created in the interface builder. Models can best be thought of as "your concept" for the application and I am going to generalize the controller as the code.</span><br /><span><br /></span><br /><span><br /></span><br /><b><u><span>Basic Interaction:</span></u></b><br /><span><br /></span><br /><span>After starting a view-based application, we get all of that handy objective-C stub code. The xib files (pronounced "nib") open up in interface builder. We can drag and drop elements (such as text boxes, buttons, text views, etc) into the applications view. </span><br /><span><br /></span><br /><span>The interactions between the elements we just selected are defined in the @interface section of the viewController.h file. Pretend we have a text box where a user enters text, a text view to show whatever the user submitted in the text box, and a button to process the action. The text box and text fields would be IBOutlet objects (they are outlets for actions) and the button would be an IBAction object (because we use the button to perform an action).</span><br /><span><br /></span><br /><span>So let's crack open the header file.</span><br /><span><br /></span><br /><span>@interface someViewController : UIViewController {</span><br /><span>  IBOutlet UITextField *message;</span><br /><span>  IBOutlet UILabel *label;</span><br /><span>}</span><br /><span><br /></span><br /><span>We also define @property (nonatomic, retain) for the objects we intend to use (under the @interface section).</span><br /><span><br /></span><br /><span>@property (nonatomic, retain) IBOutlet UITextField *message;</span><br /><span>@property (nonatomic, retain) IBOutlet UILabel *label;</span><br /><span><br /></span><br /><span>The button requires a method declaration (IBAction).</span><br /><span><br /></span><br /><span>- (IBAction) lightsCameraAction;</span><br /><span><br /></span><br /><span>Now we go the the implementation (.m file).</span><br /><span><br /></span><br /><span>@implementation someViewController</span><br /><span><br /></span><br /><span>@synthesize message;</span><br /><span>@synthesize label;</span><br /><span><br /></span><br /><span>- (IBAction) lightsCameraAction {</span><br /><span>  NSString *internalTemporaryStorage = [[NSString alloc] initWithFormat:@"Your text, %@", message.text];</span><br /><span>  label.text = internalTemporaryStorage;</span><br /><span>  [internalTemporaryStorage release];</span><br /><span>}</span><br /><span><br /></span><br /><span>The last step is to go back to the interface builder and literally connect the objects to each other. We have to click on the "File's Owner" box and connect the label object to the text view. We have to connect the message object to the text field. And finally, we have to connect the performSomeAction method to the button (and be sure to set the button action to be "touch up inside").</span></p>
